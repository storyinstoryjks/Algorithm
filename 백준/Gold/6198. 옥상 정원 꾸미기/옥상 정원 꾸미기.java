// Stack : 6198
/*
1) Solution 1 - 스택: top <= 현재 빌딩의 높이인 경우, Index차를 통해 ans배열 조정.
2) Solution 2 - Monotonic Stack(단조 스택) - 내림차순을 유지하는 스택

[Solution 1 알고리즘]
=> 스택의 원소는 각 빌딩 높이에 해당하는 인덱스
=> top <= 현재 빌딩 높이인 경우, pop을 진행하며, 이 때 (현재 빌딩 높이의 인덱스 - pop된 빌딩의 높이의 인덱스-1)를 인덱스로 삼아 ans에 삽입.
=> 다음 아래 예시.
10 : 스택[10]
3 : 스택[10,3]
7 : top(=3) <= 현재(=7)이므로, pop 진행 -> 2(7의 인덱스)-1(3의 인덱스)-1=0을 ans[1(3의 인덱스)]의 값으로 삽입.
(즉, 인덱스차-1의 의미는 pop한 빌딩이 몇개의 빌딩까지 볼 수 있냐를 의미한다.)

=> 그러나, 선택하지 않음. 그 이유는 다음과 같은 예시에 있다.
빌딩리스트 : 10 3 7 12 2 2
==> for문 순회 완료 시, 스택은 [3,4,5]이다.
==> 즉, [3,4,5]를 역순으로 다시 순회해야 하기에, for문이 한번더 쓰임.
==> 최악의 경우, for문이 여러번 쓰일 수 있음.

=> 즉 이 알고리즘의 시간 복잡도는 O(n*k)가 된다. (k는 상수==for문이 쓰인 횟수)

[Solution 2 알고리즘]
=> 이 알고리즘을 생각하는데까지 시간이 꽤 소요됨.
=> 다음과 같은 생각의 과정을 거쳐 결정하였다.

1. 시간복잡도가 O(n)에 가까워지긴 위해선, for문을 한두번 써야됨.
2. 빌딩의 개수만큼 for문을 바탕으로 순회할 것이고, 각 단계에서 어떤 연산을 처리해야됨.
3. "각 단계에서 어떤 연산을 처리" == 이번 순회에 해당되는 빌딩을 기준으로 카운팅이 들어가야됨.
4. 순회 과정을 직접 생각해봄.
==> 현재 단계 10 : 아무 연산 처리 필요없음.
==> 현재 단계 3 : 이 빌딩이 볼 수 있는 빌딩을 판별하려면 다음 빌딩과 비교해야됨. 저장 그릇이 필요함.
==> 여기서 막힘.

다시 생각해봄. "이번 순회에 해당되는 빌딩을 기준"==현재단계까지의 해당되는 빌딩들이 보는 개수 카운팅으로 기준잡음.
현재 단계 10 : 아무것도 볼 수 없음.
현재 단계 3 : 10은 3을 볼 수 있음.
현재 단계 7 : 10은 7을 볼 수 있음. 3은 7을 볼 수 없음.
...

=> 여기서, 단계 7에서 2가지 규칙을 발견.
(1. 주어가 10이라는 것.) (2. 3은 카운팅할 필요가 없으므로 빼야됨.==각 순회 과정에서 삭제 연산이 들어가야함.)
=> 규칙을 종합해봄.
위 2가지 규칙 + "이번 순회에 해당되는 빌딩을 기준으로 카운팅이 들어가야됨." + "저장 그릇이 필요함"

=> "스택을 활용한 저장 그릇에, 각 순회 과정에서 삭제 연산을 진행한다."
=> "기준: 현재 단계까지의 해당되는 빌딩들이 보는 개수"

10 : [] ==> 스택이 공란이므로, 아무도 10을 볼 수 없음. 카운팅 0. 이후, 10 스택에 삽입.
3 : [10] ==> 스택이 공란이 아니고, 10은 3을 볼 수 있음. 카운팅 1. 이후, 3 스택에 삽입.
7 : [10 3] ==> 스택이 공란이 아니고, 10은 3을 볼 수 있지만, 3은 7을 볼 수 없음. pop진행.
-- 7 : [10] ==> 카운팅 1. 이를 통해 pop의 규칙은 'top <= list[i]'임을 알 수 있음. 이후, 7 삽입.
4 : [10 7] ==> 10과 7은 4를 볼 수 있음. 카운팅 2. 이후, 4 삽입.
12 : [10 7 4] ==> 아무도 볼 수 없으므로, 3번의 pop진행. 스택은 공란이므로, 카운팅 0.
2 : [12] ==> 12는 2를 볼 수 있음. 카운팅 1., 순회 끝. (2는 마지막이므로, 카운팅 필요없음)

총 카운팅 = 0+1+1+2+0+1 = 5

"이를 통해, for문 안에서, 스택과 pop연산을 활용하면서 각 순회마다 카운팅을 진행."
"카운팅은 스택 안의 원소들의 개수. 즉, 스택의 길이를 카운팅하는 것."
"여기서, 스택의 변화를 보면 내림차순으로 정렬을 유지하는 것을 알 수 있음."
"내림차순 정렬은 단조 스택의 기능 중 하나임을 알 수 있음."

=> 이 문제는 "각 순회 시, 해당 빌딩을 볼 수 있는 빌딩들을 카운팅" + "카운팅의 수단은 단조 스택 + 스택의 길이"가 핵심이다.
*/

import java.util.*;
import java.io.*;

public class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static long n,cnt=0;
    public static void main(String[] args) throws IOException{
        Stack<Integer> buildings= new Stack<>();
        
        n=Integer.parseInt(new StringTokenizer(br.readLine()).nextToken());
        for(int i=0; i<n; i++){
            int current=Integer.parseInt(new StringTokenizer(br.readLine()).nextToken());

            while(!buildings.empty() && buildings.peek() <= current){
                buildings.pop();
            }

            cnt+=(long)buildings.size();
            buildings.add(current);
        }

        System.out.println(cnt);
        br.close();
    }
}
